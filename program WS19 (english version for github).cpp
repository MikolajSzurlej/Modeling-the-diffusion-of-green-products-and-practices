#include <stdlib.h>
#include <iostream>
#include <sstream>
#include "MersenneTwister.h"	//random number generator
#include <string>
#include <cstdio>
#include <fstream>
#include <regex>
#include <cmath>
#include <vector>
#include <bits/stdc++.h>
//#include <windows.h>

using namespace std;

// int to string function
string int_to_str(int i)
{
    std::stringstream out;
    out << i;
    return out.str();
}

// float to string function
string float_to_str(float p_eng)
{
    std::stringstream out;
    out << p_eng;
    return out.str();
}

// string to int function
int str_to_int(string s)
{
    std::stringstream out(s);
    int i = 0;
    out >> i;
    return i;
}

// string to float function
float str_to_float(string s)
{
    std::stringstream out(s);
    float p_eng = 0.0;
    out >> p_eng;
    return p_eng;
}

// working folder path function
//string workingdir()
//{
    //char wd[256];
    //GetCurrentDirectoryA(256, wd);
    //return string(wd) + "\\";
//}

// global variables
//string folder_main = workingdir();    // main folder with exe and graphs

// function for parameters N, T, p_ind, q, p_eng, k, b i g (graph number)
// download adjacency matrix and generate trajectories and save them to file
void trajectory(int N, int T, float p_ind, int q, float p_eng, int k, float b, int g, vector< vector<int> > &small_world)
{
	//////////////////////////////////////////////////////////////////////////////////////////
	////////// local variables //////////
	
	MTRand generator;    // random number generator
	string file_results;    // name of the result file in which the trajectory will be saved for a given set of parameters
	int  sum_opinions;    // is used to calculate the sum of opinions of all agents in a given time step, then the result is saved to the 'list_sum_opinions' list
	//string graph_name;    // name of the txt file generated by Python from which we will read the adjacency matrix
	//vector <int> small_world[N];    // a vector writing the adjacency matrix from a txt file generated by Python
	//string row;    // a variable used to save subsequent lines of the txt file generated by Python, which contains the adjacency matrix
	vector <int> neighbors;    // a vector used to temporarily store the neighborhood list of a randomly selected agent to randomly select a q-panel
	int neighbor_idx;    // current index of the neighbor drawn from the 'neighbors' list, used when drawing the q-panel
	int group_of_influence[q];    // a list containing the numbers of influence group members
	int q_panel_opinion;    // is used to calculate the sum of opinions of q-panel members
	int agent;    // is used to remember the number of the currently drawn agent, which will decide about changing the opinion
	float prob_independence;    // random number checking the truth. being independent (prob_independence < p_ind)
	float prob_engagement;    // random number checking the truth. changes to 'yes' (prob_engagement < p_eng)
	bool orientation[N] = {false};    // a list storing the current opinion of agents, the initial value is 'no', i.e. false (bool can be faster than int?)
	//string parameters;    // "progress bar", an auxiliary variable that displays in the console a set of parameters for which calculations have already been performed
	//string folder_name;    // name of the resulting folder for trajectories for the current parameters
	
	///////////////////////////////////////////////////////////////////////////////////////
	////////// saving adjacency matrix from txt file to vector small_world //////////
	float b_out = b*100;
	float p_eng_out = p_eng*100;
	float p_ind_out = p_ind*100;
	//folder_name = "Results_N_" + int_to_str(N) + "_beta_" + float_to_str(b_out) + "_k_" + int_to_str(k) + "_q_" + int_to_str(q) + "_p_ind_" + float_to_str(p_ind_out) + "_p_eng_" + float_to_str(p_eng_out);
	
	//SetCurrentDirectory(folder_main.c_str());    // let's change the folder to the main one, because there are graphs in it

	//SetCurrentDirectory(folder_name.c_str());    // change to the result folder to save trajectories there
	file_results = "trajectory_N_" + int_to_str(N) + "_beta_" + float_to_str(b_out) + "_k_" + int_to_str(k) + "_q_" + int_to_str(q) + "_p_ind_" + float_to_str(p_ind_out) + "_p_eng_" + float_to_str(p_eng_out) + "_graph_" + int_to_str(g) + ".txt";
	ofstream results;    // we create a variable on 'file_results'
	results.open(file_results.c_str(), ios::out);    // open 'file_results'
	results << 0 << ",";
	
	/////////////////////////////////////////////////////////////////////////
	////////// main body of the function, iteration over time steps //////////
	
	for (int i_T = 0; i_T < T; i_T++)    // T loop
	{
		for (int n = 0; n < N; n++)    // N loop
		{
			agent = generator.randInt(N - 1);    // we draw an agent
			prob_independence = generator.rand();    // we check whether the randomly selected agent is independent
			///// independence /////
			if (prob_independence < p_ind)    // the agent is independent
			{
				prob_engagement = generator.rand();    // we check whether the randomly selected agent will change his mind to 'yes'
				if (prob_engagement < p_eng)    // agent changes his mind to 'yes'
				{
					orientation[agent] = true;
				}
				else    // agent zmienia zdanie na 'nie'
				{
					orientation[agent] = false;
				}
			}
			///// conformity /////
			else    // agent is conformist
			{
				for (int s = 0; s < small_world[agent].size(); s++)    // we iterate through the neighbors of the randomly selected agent
				{
					neighbors.push_back(small_world[agent][s]);    // we enter the neighbors of the randomly selected agent into the temporary 'neighbors' list
				}
				for (int s = 0; s < q; s++)    // we draw and remove selected neighbors from the list (q times)
				{										
					neighbor_idx = generator.randInt(neighbors.size() - 1);    // we draw one neighbor from the list (we draw its index in the 'neighbors' list)
					group_of_influence[s] = neighbors[neighbor_idx];    // we add the number (not the index!) of the selected neighbor to the influence group
	    			neighbors.erase(neighbors.begin() + neighbor_idx);    // we remove the drawn neighbor from the 'neighbors' list because we draw without repetition
				}
				
				q_panel_opinion = 0;
				for (int s = 0; s < q; s++)
				{
					q_panel_opinion = q_panel_opinion + orientation[group_of_influence[s]];    // we count the sum of the opinions of the influence group
				}
				
				// we check the unanimity of the influence group
				if ((q_panel_opinion == 0) && (orientation[agent] == 1))    // the group is 'no' and the agent is 'yes'
				{
					orientation[agent] = false;    // the agent is a conformist, so he changes his mind to 'no'
				}
				else if ((q_panel_opinion == q) && (orientation[agent] == 0))    // the group is 'yes' and the agent is 'no'
				{
					orientation[agent] = 1;    // the agent is a conformist, so he changes his mind to 'yes'
				}
				neighbors.clear();    // we clean the 'neighbors' list because not every agent has the same number of neighbors, so there could be errors
			}	
		}
		
		///// counting the sum of opinions in a given time step and saving it to the result list /////
		 sum_opinions = 0;
		for (int n = 0; n < N; n++)
		{
			 sum_opinions =  sum_opinions + orientation[n];    // we count the sum of agents' opinions in a given time step
		}
		
		// we save the calculated sum to a file
		if (results.is_open())
		{
			results <<  sum_opinions << ",";    // we save the sums of opinions in subsequent time steps separated by commas to the file
		}
		else
		{
			cout << "The file could not be opened" << file_results << endl;
		}
	}
	
	results.close();
	//parameters = "N = " + int_to_str(N) + ", beta = " + float_to_str(b) + ", k = " + int_to_str(k) + ", q = " + int_to_str(q) + ", p_ind = " + float_to_str(p_ind) + ", p_eng = " + float_to_str(p_eng) + ", graph " + int_to_str(g);
	//cout << parameters << endl;
}

int main()
{
	////////////////////////////////////////////////////////////
	////////// initial declaration of local variables //////////
	
	int N;    // network size
	int T;    // simulation time
	int LS;    // average number
	float q_min;    // minimum size of the influence group
	float q_max;    // maximum influence group size
	float dq;    // influence group size delta
	float p_eng_min;    // minimum truth value changes to 'yes'
	float p_eng_max;    // maximum truth value changes to 'yes'
	float dp_eng;    // delta truth value changes to 'yes'
	float b_min;    // minimum truth value disconnection in the WS network
	float b_max;    // maximum truth value disconnection in the WS network
	float db;    // delta truth value disconnection in the WS network
	int k_min;    // minimum average number of neighbors in the WS network
	int k_max;    // maximum average number of neighbors in the WS network
	int dk;    // delta - the average number of neighbors in the WS network
	float p_ind_min;    // minimum truth value being independent
	float p_ind_max;    // maximum truth value being independent
	float dp_ind;    // delta truth value being independent
	
	/////////////////////////////////////////////////////////////
	////////// reading parameters from the init.txt file //////////
	
	regex rx(R"((?:^|\s)([+-]?[[:digit:]]+(?:\.[[:digit:]]+)?)(?=$|\s))");    // regular expression that searches for integers and floating-point numbers in the text
	smatch m;    // a variable that stores the results of the search in the text of the above regular expression
	string row;    // a variable storing one line from the init.txt initialization file
	
	ifstream init ("init.txt");    // we open the init.txt file and save it to the 'init' variable
	if (init.is_open())
	{
		while (getline(init, row))    // we iterate through the lines of the init.txt file
		{
			regex network_size("network size");    // regular expression that searches for the phrase "network size" in the text
			bool match = regex_search(row, network_size);    // a logical variable that evaluates to true if the above expression appears on a given line
			if (match)    // the given row 'row' contains the regular expression 'network_size'
			{
				regex_search(row, m, rx);    // we search the given row 'row' and save the numbers found by the regular expression 'rx' to the variable 'm'
				N = str_to_int(m[1]);    // 'm[1]' is the network size we are looking for, so we save it to the variable 'N'
				cout << "N " << N << endl;    // we write the read value in the console
			}
			regex simulation_time("simulation time");    // we perform similar operations for subsequent arguments of the init.txt file
			match = regex_search(row, simulation_time);
			if (match)
			{
				regex_search(row, m, rx);
				T = str_to_int(m[1]);
				cout << "T " << T << endl;
			}
			regex number_of_averages("number of averages");
			match = regex_search(row, number_of_averages);
			if (match)
			{
				regex_search(row, m, rx);
				LS = str_to_int(m[1]);
				cout << "LS " << LS << endl;
			}
			regex q_minimum("q_min");
			match = regex_search(row, q_minimum);
			if (match)
			{
				regex_search(row, m, rx);
				q_min = str_to_int(m[1]);
				cout << "q_min " << q_min << endl;
			}
			regex q_maximum("q_max");
			match = regex_search(row, q_maximum);
			if (match)
			{
				regex_search(row, m, rx);
				q_max = str_to_int(m[1]);
				cout << "q_max " << q_max << endl;
			}
			regex delta_q("dq");
			match = regex_search(row, delta_q);
			if (match)
			{
				regex_search(row, m, rx);
				dq = str_to_int(m[1]);
				cout << "dq " << dq << endl;
			}
			regex p_eng_minimum("p_eng_min");
			match = regex_search(row, p_eng_minimum);
			if (match)
			{
				regex_search(row, m, rx);
				p_eng_min = str_to_float(m[1]);
				cout << "p_eng_min " << p_eng_min << endl;
			}
			regex p_eng_maximum("p_eng_max");
			match = regex_search(row, p_eng_maximum);
			if (match)
			{
				regex_search(row, m, rx);
				p_eng_max = str_to_float(m[1]);
				cout << "p_eng_max " << p_eng_max << endl;
			}
			regex delta_p_eng("dp_eng");
			match = regex_search(row, delta_p_eng);
			if (match)
			{
				regex_search(row, m, rx);
				dp_eng = str_to_float(m[1]);
				cout << "dp_eng " << dp_eng << endl;
			}
			regex b_minimum("b_min");
			match = regex_search(row, b_minimum);
			if (match)
			{
				regex_search(row, m, rx);
				b_min = str_to_float(m[1]);
				cout << "b_min " << b_min << endl;
			}
			regex b_maximum("b_max");
			match = regex_search(row, b_maximum);
			if (match)
			{
				regex_search(row, m, rx);
				b_max = str_to_float(m[1]);
				cout << "b_max " << b_max << endl;
			}
			regex delta_b("db");
			match = regex_search(row, delta_b);
			if (match)
			{
				regex_search(row, m, rx);
				db = str_to_float(m[1]);
				cout << "db " << db << endl;
			}
			regex k_minimum("k_min");
			match = regex_search(row, k_minimum);
			if (match)
			{
				regex_search(row, m, rx);
				k_min = str_to_int(m[1]);
				cout << "k_min " << k_min << endl;
			}
			regex k_maximum("k_max");
			match = regex_search(row, k_maximum);
			if (match)
			{
				regex_search(row, m, rx);
				k_max = str_to_int(m[1]);
				cout << "k_max " << k_max << endl;
			}
			regex delta_k("dk");
			match = regex_search(row, delta_k);
			if (match)
			{
				regex_search(row, m, rx);
				dk = str_to_int(m[1]);
				cout << "dk " << dk << endl;
			}
			regex p_ind_minimum("p_ind_min");
			match = regex_search(row, p_ind_minimum);
			if (match)
			{
				regex_search(row, m, rx);
				p_ind_min = str_to_float(m[1]);
				cout << "p_ind_min " << p_ind_min << endl;
			}
			regex p_ind_maximum("p_ind_max");
			match = regex_search(row, p_ind_maximum);
			if (match)
			{
				regex_search(row, m, rx);
				p_ind_max = str_to_float(m[1]);
				cout << "p_ind_max " << p_ind_max << endl;
			}
			regex delta_p_ind("dp_ind");
			match = regex_search(row, delta_p_ind);
			if (match)
			{
				regex_search(row, m, rx);
				dp_ind = str_to_float(m[1]);
				cout << "dp_ind " << dp_ind << endl;
			}
		}
		init.close();    // close the init.txt file
	}
	else    // in case of problems opening the init.txt file
	{
		cout << "The init.txt file could not be opened" << endl;
	}
	
	///////////////////////////////////////////////////////////////
	////////// calculating the number of parameters for simulation //////////
	
	int length_q = floor((q_max - q_min)/dq) + 1;    // number of all q
	int length_p_eng = floor((p_eng_max - p_eng_min)/dp_eng) + 1;    // number of all p_eng
	int length_b = floor((b_max - b_min)/db) + 1;    // number of all b
	int length_p_ind = floor((p_ind_max - p_ind_min)/dp_ind) + 1;    // number of all p_ind
	int length_k = floor((k_max - k_min)/dk) + 1;    // number of all k
	
	//////////////////////////////////////////////////////////////////////////////////////////////////
	////////// variable declaration, parameter loops and calling the trajectory() function //////////
	
	int q;    // a variable storing the value of q in a given loop lunch
	float p_eng;    // a variable storing the value of p_eng in a given loop lunch
	float p_ind;    // a variable storing the value of p_ind in a given loop lunch
	float b;    // a variable storing the value of b in a given loop lunch
	int k;    // a variable storing the value of k in a given loop lunch
	//string folder_name;    // name of the resulting folders for trajectories for various parameters
	float b_out;
	//float p_ind_out;
	//float p_eng_out;
	string graph_name;    // name of the txt file generated by Python from which we will read the adjacency matrix
	//list < vector<int> > small_world;
	vector< vector<int> > small_world;
	//vector <int> *small_world;    // a vector writing the adjacency matrix from a txt file generated by Python
	//small_world = new vector<int>[N];
	//string row;    // a variable used to save subsequent lines of the txt file generated by Python, which contains the adjacency matrix
	
	
		for (int i_q = 0; i_q < length_q; i_q++)    // loop after q
		{
			q = q_min + i_q * dq;    // calculating the value of q in a given loop
			
			for (int i_k = 0; i_k < length_k; i_k++)    // loop after k
			{
				k = k_min + i_k * dk;    // calculating the value of k in a given loop
				
				for (int i_b = 0; i_b < length_b; i_b++)     // loop after b
				{
					b = b_min + i_b * db;    // calculating the value of b in a given loop
					
					for (int i_p_eng = 0; i_p_eng < length_p_eng; i_p_eng++)    // loop after p_eng
					{
						p_eng = p_eng_min + i_p_eng * dp_eng;    // calculating the value of p_eng in a given loop
						
						for (int i_LS = 0; i_LS < LS; i_LS++)    // loop after LS
						{
							// using parameters, we create the name of the txt file generated by Python, which contains the adjacency matrix
							b_out = b*100;
							graph_name = "N_" + int_to_str(N) + "_beta_" + float_to_str(b_out) + "_k_" + int_to_str(k) + "_graph_" + int_to_str(i_LS) + ".txt";
							ifstream graph;
							graph.open(graph_name.c_str(), ios::in);    // we open the 'graph_name' file and save it to the 'graph' variable
							if (graph.is_open())
							{
								int a = 0;    // a variable iterating over agent numbers
								while (getline(graph, row))    // we iterate over the lines of the 'graph_name' file
								{
									vector<int> temp;
									stringstream iss(row);    // saves a line of file as a stream of strings to the variable 'iss' ("is string")
									int number;    // used to remember subsequent numbers in a stream of strings
						
									while (iss >> number)
									{
										temp.push_back(number);
										if (iss.peek() == ',')    // we ignore commas that affect neighbor numbers in the 'graph_name' file
										{
											iss.ignore();
										}
									}
									small_world.push_back(temp);    // to the 'small_world' vector, in the line corresponding to the agent number 'j', we write down the numbers of its neighbors
									a = a + 1;
								}
								graph.close();    // close the 'graph_name' file
							}
							else    // in case of problems opening the 'graph_name' file
							{
								cout << "The file could not be opened" << graph_name << endl;
							}
							
							//p_eng_out = p_eng*100;
							//p_ind_out = p_ind*100;
							//SetCurrentDirectory(folder_main.c_str());
							//folder_name = "Results_N_" + int_to_str(N) + "_beta_" + float_to_str(b_out) + "_k_" + int_to_str(k) + "_q_" + int_to_str(q) + "_p_ind_" + float_to_str(p_ind_out) + "_p_eng_" + float_to_str(p_eng_out);
							//CreateDirectory(folder_name.c_str(), NULL);
							
							// here we parallelized the program according to Bartek's advice to count 8 loop calls on other threads
							// therefore, for a given set of parameters (N, T, p_ind, q, p_eng, k, b, g), the trajectory() function is called in parallel
							int i_p_ind;    // we declare a loop counter to pass it as a private parameter in parallel
							
							#pragma omp parallel for shared(length_p_ind, dp_ind, N, T, q, p_eng, k, b, small_world, i_LS) private(i_p_ind, p_ind) num_threads(8)
							for (i_p_ind = 0; i_p_ind < length_p_ind; i_p_ind++)    // loops by the number of averages
							{	
								p_ind = p_ind_min + i_p_ind * dp_ind;
								trajectory(N, T, p_ind, q, p_eng, k, b, i_LS, small_world);    // we call the trajectory() function
							}
							
							small_world.clear();
							cout << "graph " << i_LS<< " done " << endl;
						}
					}
				}
			}
		}
	
	return 0;
}

